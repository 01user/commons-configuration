<?xml version="1.0"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<document>

 <properties>
  <title>Configuration Events Howto</title>
  <author email="oheger@apache.org">Oliver Heger</author>
 </properties>

<body>
    <section name="Events">
    <p>
      Many Java libraries support the <em>observer pattern</em> to send
      notifications about state changes to registered observers. The domain
      configuration data has also some important use cases for such
      notifications. For instance, an application may want to be notified when
      certain changes on configuration data are done or when a configuration
      file was modified by an external source. For such requirements
      <em>Commons Configuration</em> offers a powerful event mechanism.
    </p>

    <subsection name="Event Sources and Listeners">
    <p>
      In <em>Commons Configuration</em>, there is a central interface for all
      objects that can generate events:
      <code><a href="../apidocs/org/apache/commons/configuration/event/EventSource.html">
      EventSource</a></code>. Here methods for adding and removing event listeners
      are defined with the following signatures:
    </p>
    <source><![CDATA[
    <T extends Event> void addEventListener(EventType<T> eventType,
            EventListener<? super T> listener);

    <T extends Event> boolean removeEventListener(EventType<T> eventType,
            EventListener<? super T> listener);
]]></source>
    <p>
      Users who are familiar with JavaFX will recognize some similarities to
      the event mechanism used in this UI library. In the generation of
      notifications the following components are involved:
      <ul>
        <li>An <em>event</em> object which contains all information about a
        specific change which has happened.</li>
        <li>Each event is associated with a specific <em>event type</em>. The
        event type also determines the class of the event. For different kinds
        of notifications, different event classes exist which also define their
        own specific set of properties.</li>
        <li>An event listener which is invoked with an event object when
        something happens for which it has been registered.</li>
      </ul>
    </p>
    <p>
      The type parameters in the methods of the <code>EventSource</code>
      interface ensure a type-safe registration of event listeners. As we will
      see in the next section, events are organized in a logic hierarchy. An
      event listener has to implement the
      <code><a href="../apidocs/org/apache/commons/configuration/event/EventListener.html">
      EventListener</a></code> interface. This interface has a type parameter
      for the event type which can be processed. The listener can process events
      of this specific type and also events derived from this type. So listeners
      can be registered for very generic events, but also for specific ones.
      This allows for filtering of events in a pretty natural way. The
      <code>EventListener</code> interface defines a single method
      <code>onEvent()</code> which expects an event of the type defined by the
      generic parameter of the interface.
    </p>
    <p>
      <em>Commons Configuration</em> provides the following implementations of
      the <code>Event Source</code> interface:
      <dl>
        <dt>Configuration objects</dt>
        <dd>Each configuration allows registering event listeners and generates
        events when it is updated.</dd>
        <dt><a href="howto_builders.html">Configuration builders</a></dt>
        <dd>A typical configuration builder sends out events when its managed
        configuration becomes invalid or when a new managed instance was
        created.</dd>
        <dt><a href="howto_reloading.html">Reloading controllers</a></dt>
        <dd>Here events are generated when a change in a monitored configuration
        source was detected.</dd>
      </dl>
    </p>
    <p>
      In the following sections these event sources are discussed in more
      detail. But first we have to elaborate a bit more on the hierarchical
      nature of events and how this is related to event listeners.
    </p>
    </subsection>

    <subsection name="The Hierarchy of Events">
    <p>
      All events generated by components in <em>Commons Configuration</em> are
      derived from the
      <code><a href="../apidocs/org/apache/commons/configuration/event/Event.html">
      Event</a></code> class. This base class is pretty simple. It has a
      property for the source - inherited from the <code>java.util.EventObject</code>
      super class and an event type. The event type can be used for instance
      in an event listener that has been registered for multiple events to
      find out what actually happened.
    </p>
    <p>
      Event types are an interesting concept. They are represented by the
      <code><a href="../apidocs/org/apache/commons/configuration/event/EventType.html">
      EventType</a></code> class. At first, an event type has a type parameter
      which associates it with a specific event class. This parameter is checked
      by the compiler to validate event listener registrations via the methods
      of the <code>EventSource</code> interface. Second, an event type can have
      a super type. With this information event types actually form a logic
      hierarchy. This is taken into account to find out which event listeners
      have to be invoked when an event of a specific type is received.
    </p>
    <p>
      As an example, below is an excerpt of the hierarchy of event types for
      events related to configuration updates (the full hierarchy is described
      in a later section):
      <ul>
        <li>Event.ANY</li>
        <ul>
          <li>ConfigurationEvent.ANY</li>
          <ul>
            <li>ConfigurationEvent.ADD_PROPERTY</li>
            <li>ConfigurationEvent.SET_PROPERTY</li>
            <li>...</li>
          </ul>
        </ul>
      </ul>
    </p>
    <p>
      An <code>EventListener&lt;ConfigurationEvent&gt;</code> can be
      registered for the generic event type <code>ConfigurationEvent.ANY</code>
      or for one of the specific event types (like <code>ADD_PROPERTY</code> or
      <code>SET_PROPERTY</code>). If it has been registered for the generic
      type, it is triggered for all events whose type is derived from this
      generic type. For instance, it would be called for an event of type
      <code>ConfigurationEvent.ADD_PROPERTY</code>. In contrast, if a specific
      event type is used for the event listener registration, only events of
      this type trigger this listener. The following code fragement shows how
      an event listener is registered at a configuration object for a specific
      event type:
    </p>
    <source><![CDATA[
EventListener<ConfigurationEvent> listener = new MyListner();
config.addEventListener(ConfigurationEvent.ADD_PROPERTY, listener);
]]></source>
    <p>
      This listener would be called for events of type <code>ADD_PROPERTY</code>,
      but not for <code>SET_PROPERTY</code> events. Note that it would not be
      possible to register this event listener for the base type
      <code>Event.ANY</code>. Because the listener is of type
      <code>EventListener&lt;ConfigurationEvent&gt;</code> its <code>onEvent()</code>
      method expects a <code>ConfigurationEvent</code>; so the basic type
      <code>Event</code> is not sufficient to invoke this listener.
    </p>
    <p>
      Event types are defined as constants in the event classes they are related
      to. Typically, there are multiple event type constants per event class
      because an event object (viewed as a container of related properties) can
      occur in multiple concrete contexts or be used for different operations.
    </p>
    </subsection>

    <subsection name="Configuration Update Events">
    <p>
      All configuration implementations derived from
      <code><a href="../apidocs/org/apache/commons/configuration/AbstractConfiguration.html">
      AbstractConfiguration</a></code> can generate events of type
      <code><a href="../apidocs/org/apache/commons/configuration/event/ConfigurationEvent.html">
      ConfigurationEvent</a></code> when they are manipulated. In addition to
      the properties inherited from the <code>Event</code> base class, a
      configuration event contains all information available about the
      modification:
      <ul>
        <li>If available, the name of the property whose modification caused the
        event.</li>
        <li>If available, the value of the property that caused this event.</li>
        <li>A flag whether this event was generated before or after the update
        of the source configuration. A modification of a configuration typically
        causes two events: one event before and one event after the modification
        is performed. This allows event listeners to react at the correct point
        of time.</li>
      </ul>
      Depending on the concrete event type not all of this data may be available.
    </p>
    <p>
      <code>ConfigurationEvent</code> defines a number of <code>EventType</code>
      constants for the possible types of such an event. These constants
      correspond to the methods available for updating a configuration. The
      hierarchy of these event types is listed below, together with a
      description of the specific types and their available properties:
    </p>
    <p>
      <ul>
        <li><strong>Event</strong></li>
        <ul>
          <li><strong>ConfigurationEvent.ANY</strong> is a placeholder for all types
          of configuration update events. A listener registered for this
          event type is actually invoked for each manipulation of the source
          configuration.</li>
          <ul>
            <li><strong>ADD_PROPERTY</strong> A property was added to the
            configuration. The event object contains the name of the affected
            property and the value passed to the <code>addProperty()</code>
            method.</li>
            <li><strong>SET_PROPERTY</strong> The value of a property was
            changed. The event contains the name of the affected property and
            its new value.</li>
            <li><strong>CLEAR_PROPERTY</strong> A property was removed from the
            configuration. In the event the name of the removed property is
            stored.</li>
            <li><strong>CLEAR</strong> The whole configuration was cleared. The
            event object does not contain any additional information.</li>
            <li><strong>ANY_HIERARCHICAL</strong> This is a common super type
            for all events specific to hierarchical configurations. The event
            types derived from this type correspond to the special update
            methods supported by hierarchical configurations.</li>
            <ul>
              <li><strong>ADD_NODES</strong> A collection of nodes was added to
              a hierarchical configuration. The event contains the key passed
              to the <code>addNodes()</code> method and the collection of new
              nodes as value.</li>
              <li><strong>CLEAR_TREE</strong> This event is triggered by the
              <code>clearTree()</code> method. It contains the key of the
              sub tree which was removed; it has no value.</li>
              <li><strong>SUBNODE_CHANGED</strong> This event indicates that a
              <code>SubnodeConfiguration</code> created by this configuration
              was changed. The <em>value</em> property of the event object
              contains the original event object as it was sent by the subnode
              configuration.</li>
            </ul>
          </ul>
        </ul>
      </ul>
    </p>
    <p>
      After all the theory about the different event types, let's come to a
      concrete example. Implementing an event listener for configuration
      events is quite easy. To prove this and as a kind of "Hello world" use
      case, we are going to define an event listener which logs all received
      configuration events to the console. The class could look as follows:
    </p>
    <source><![CDATA[
import org.apache.commons.configuration.event.ConfigurationEvent;
import org.apache.commons.configuration.event.EventListener;

public class ConfigurationLogListener implements EventListener<ConfigurationEvent>
{
    public void onEvent(ConfigurationEvent event)
    {
        if (!event.isBeforeUpdate())
        {
            // only display events after the modification was done
            System.out.println("Received event!");
            System.out.println("Type = " + event.getEventType());
            if (event.getPropertyName() != null)
            {
                System.out.println("Property name = " + event.getPropertyName());
            }
            if (event.getPropertyValue() != null)
            {
                System.out.println("Property value = " + event.getPropertyValue());
            }
        }
    }
}
]]></source>
    <p>
      Now an instance of this event listener class has to be registered at a
      configuration object (Note: in a later section we will learn how event
      listeners can be added to configurations via their associated builders;
      this is the preferred way):
    </p>
    <source><![CDATA[
AbstractConfiguration config = ... // somehow create the configuration
EventListener<ConfigurationEvent> listener = new ConfigurationLogListener();
config.addEventListener(ConfigurationEvent.ANY, listener);
...
config.addProperty("newProperty", "newValue"); // will fire an event
]]></source>
    <p>
      Because our implementation is a very generic event listener it has been
      registered for all kinds of configuration update events - the event type
      <code>ConfigurationEvent.ANY</code> was used. Now consider the case that
      we only want to log events about cleared properties. This can be easily
      achieved - without having to modify the event listener implementation -
      by just changing the registration code in the following way:
    </p>
    <source><![CDATA[
config.addEventListener(ConfigurationEvent.CLEAR_PROPERTY, listener);
...
config.addProperty("newProperty", "newValue"); // will NOT fire an event
config.clearProperty("removedProperty"); // but this one will
]]></source>
    </subsection>

    <subsection name="Error listeners">
    <p>
      Some implementations of the <code>Configuration</code> interface operate
      on underlying storages that can throw exceptions on each property access.
      As an example consider <code>
      <a href="../apidocs/org/apache/commons/configuration/DatabaseConfiguration.html">
      DatabaseConfiguration</a></code>: this configuration class issues an SQL
      statement for each accessed property, which can potentially cause a
      <code>SQLException</code>.
    </p>
    <p>
      In earlier versions of <em>Commons Configuration</em> such exceptions
      were simply logged and then swallowed. So for clients it was impossible
      to find out if something went wrong. From version 1.4 on there is a new
      way of dealing with those internal errors: the concept of <em>error
      listeners</em>.
    </p>
    <p>
      A configuration error listener is very similar to a regular configuration
      event listener. Instead of the <code>ConfigurationListener</code>
      interface it has to implement the
      <code><a href="../apidocs/org/apache/commons/configuration/event/ConfigurationErrorListener.html">
      ConfigurationErrorListener</a></code> interface, which defines a single method
      <code>configurationError()</code>. In case of an internal error this
      method is invoked, and a
      <code><a href="../apidocs/org/apache/commons/configuration/event/ConfigurationErrorEvent.html">
      ConfigurationErrorEvent</a></code> with information about that error is
      passed. By inheriting from <code>ConfigurationEvent</code>
      <code>ConfigurationErrorEvent</code> supports all information that is
      available for normal configuration listeners, too (e.g. the event type or
      the property that was accessed when the problem occurred; note that the
      <code>isBefore()</code> method does not really make sense for error
      events because an error can only occur after something was done, so it
      returns always <b>false</b> is this context). This data can
      be used to find out when and where the error happened. In addition there
      is the <code>getCause()</code> method that returns the <code>Throwable</code>
      object, which generated this event (i.e. the causing exception).
    </p>
    <p>
      We can now continue our example from the previous section and make our
      example configuration listener also capable of tracing error events. To
      achieve this we let the <code>ConfigurationLogListener</code> class also
      implement the <code>ConfigurationErrorListener</code> interface:
    </p>
    <source>
import org.apache.commons.configuration.event.ConfigurationEvent;
import org.apache.commons.configuration.event.ConfigurationListener;
<b>import org.apache.commons.configuration.event.ConfigurationListener;</b>

public class ConfigurationLogListener
  implements ConfigurationListener, <b>ConfigurationErrorListener</b>
{
    public void configurationChanged(ConfigurationEvent event)
    {
      // remains unchanged, see above
      ...
    }
    
    <b>public void configurationError(ConfigurationErrorEvent event)
    {
        System.out.println("An internal error occurred!");
        // Log the standard properties of the configuration event
        configurationChanged(event);
        // Now log the exception
        event.getCause().printStackTrace();
    }</b>
}
</source>
    <p>
      Now the listener object has to be registered as an error listener, too.
      For this purpose <code>AbstractConfiguration</code> provides the
      <code>addErrorListener()</code> method. The following example fragment
      shows the registration of the log listener object:
    </p>
    <source>
AbstractConfiguration config = ... // somehow create the configuration
ConfigurationListener listener = new ConfigurationLogListener();
config.addConfigurationListener(listener);
<b>config.addErrorListener((ConfigurationErrorListener) listener);</b>
...
config.addProperty("newProperty", "newValue"); // will fire an event
</source>
    <p>
      Note: <code>AbstractConfiguration</code> already implements a mechanism
      for writing internal errors to a logger object: It has the protected
      <code>addErrorLogListener()</code> method that can be called by derived
      classes to register a listener that will output all occurring internal
      errors using the default logger. Configuration implementations like
      <code>DatabaseConfiguration</code> that are affected by potential internal
      errors call this method during their initialization. So the default
      behavior of <em>Commons Configuration</em> for these classes is not
      changed: they still catch occurring exceptions and log them. However by
      registering specific error listeners it is now possible for clients to
      implement their own handling of such errors.
    </p>
    </subsection>
    </section>
</body>

</document>