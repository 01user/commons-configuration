<?xml version="1.0"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<document>

 <properties>
  <title>Configuration Events Howto</title>
  <author email="oheger@apache.org">Oliver Heger</author>
 </properties>

<body>
    <section name="Events">
    <p>
      Many Java libraries support the <em>observer pattern</em> to send
      notifications about state changes to registered observers. The domain
      configuration data has also some important use cases for such
      notifications. For instance, an application may want to be notified when
      certain changes on configuration data are done or when a configuration
      file was modified by an external source. For such requirements
      <em>Commons Configuration</em> offers a powerful event mechanism.
    </p>

    <subsection name="Event Sources and Listeners">
    <p>
      In <em>Commons Configuration</em>, there is a central interface for all
      objects that can generate events:
      <code><a href="../apidocs/org/apache/commons/configuration/event/EventSource.html">
      EventSource</a></code>. Here methods for adding and removing event listeners
      are defined with the following signatures:
    </p>
    <source><![CDATA[
    <T extends Event> void addEventListener(EventType<T> eventType,
            EventListener<? super T> listener);

    <T extends Event> boolean removeEventListener(EventType<T> eventType,
            EventListener<? super T> listener);
]]></source>
    <p>
      Users who are familiar with JavaFX will recognize some similarities to
      the event mechanism used in this UI library. In the generation of
      notifications the following components are involved:
      <ul>
        <li>An <em>event</em> object which contains all information about a
        specific change which has happened.</li>
        <li>Each event is associated with a specific <em>event type</em>. The
        event type also determines the class of the event. For different kinds
        of notifications, different event classes exist which also define their
        own specific set of properties.</li>
        <li>An event listener which is invoked with an event object when
        something happens for which it has been registered.</li>
      </ul>
    </p>
    <p>
      The type parameters in the methods of the <code>EventSource</code>
      interface ensure a type-safe registration of event listeners. As we will
      see in the next section, events are organized in a logic hierarchy. An
      event listener has to implement the
      <code><a href="../apidocs/org/apache/commons/configuration/event/EventListener.html">
      EventListener</a></code> interface. This interface has a type parameter
      for the event type which can be processed. The listener can process events
      of this specific type and also events derived from this type. So listeners
      can be registered for very generic events, but also for specific ones.
      This allows for filtering of events in a pretty natural way. The
      <code>EventListener</code> interface defines a single method
      <code>onEvent()</code> which expects an event of the type defined by the
      generic parameter of the interface.
    </p>
    <p>
      <em>Commons Configuration</em> provides the following implementations of
      the <code>Event Source</code> interface:
      <dl>
        <dt>Configuration objects</dt>
        <dd>Each configuration allows registering event listeners and generates
        events when it is updated.</dd>
        <dt><a href="howto_builders.html">Configuration builders</a></dt>
        <dd>A typical configuration builder sends out events when its managed
        configuration becomes invalid or when a new managed instance was
        created.</dd>
        <dt><a href="howto_reloading.html">Reloading controllers</a></dt>
        <dd>Here events are generated when a change in a monitored configuration
        source was detected.</dd>
      </dl>
    </p>
    <p>
      In the following sections these event sources are discussed in more
      detail. But first we have to elaborate a bit more on the hierarchical
      nature of events and how this is related to event listeners.
    </p>
    </subsection>

    <subsection name="The Hierarchy of Events">
    <p>
      All events generated by components in <em>Commons Configuration</em> are
      derived from the
      <code><a href="../apidocs/org/apache/commons/configuration/event/Event.html">
      Event</a></code> class. This base class is pretty simple. It has a
      property for the source - inherited from the <code>java.util.EventObject</code>
      super class and an event type. The event type can be used for instance
      in an event listener that has been registered for multiple events to
      find out what actually happened.
    </p>
    <p>
      Event types are an interesting concept. They are represented by the
      <code><a href="../apidocs/org/apache/commons/configuration/event/EventType.html">
      EventType</a></code> class. At first, an event type has a type parameter
      which associates it with a specific event class. This parameter is checked
      by the compiler to validate event listener registrations via the methods
      of the <code>EventSource</code> interface. Second, an event type can have
      a super type. With this information event types actually form a logic
      hierarchy. This is taken into account to find out which event listeners
      have to be invoked when an event of a specific type is received.
    </p>
    <p>
      As an example, below is an excerpt of the hierarchy of event types for
      events related to configuration updates (the full hierarchy is described
      in a later section):
      <ul>
        <li>Event.ANY</li>
        <ul>
          <li>ConfigurationEvent.ANY</li>
          <ul>
            <li>ConfigurationEvent.ADD_PROPERTY</li>
            <li>ConfigurationEvent.SET_PROPERTY</li>
            <li>...</li>
          </ul>
        </ul>
      </ul>
    </p>
    <p>
      An <code>EventListener&lt;ConfigurationEvent&gt;</code> can be
      registered for the generic event type <code>ConfigurationEvent.ANY</code>
      or for one of the specific event types (like <code>ADD_PROPERTY</code> or
      <code>SET_PROPERTY</code>). If it has been registered for the generic
      type, it is triggered for all events whose type is derived from this
      generic type. For instance, it would be called for an event of type
      <code>ConfigurationEvent.ADD_PROPERTY</code>. In contrast, if a specific
      event type is used for the event listener registration, only events of
      this type trigger this listener. The following code fragement shows how
      an event listener is registered at a configuration object for a specific
      event type:
    </p>
    <source><![CDATA[
EventListener<ConfigurationEvent> listener = new MyListner();
config.addEventListener(ConfigurationEvent.ADD_PROPERTY, listener);
]]></source>
    <p>
      This listener would be called for events of type <code>ADD_PROPERTY</code>,
      but not for <code>SET_PROPERTY</code> events. Note that it would not be
      possible to register this event listener for the base type
      <code>Event.ANY</code>. Because the listener is of type
      <code>EventListener&lt;ConfigurationEvent&gt;</code> its <code>onEvent()</code>
      method expects a <code>ConfigurationEvent</code>; so the basic type
      <code>Event</code> is not sufficient to invoke this listener.
    </p>
    <p>
      Event types are defined as constants in the event classes they are related
      to. Typically, there are multiple event type constants per event class
      because an event object (viewed as a container of related properties) can
      occur in multiple concrete contexts or be used for different operations.
    </p>
    </subsection>

    <subsection name="Configuration Update Events">
    <p>
      All configuration implementations derived from
      <code><a href="../apidocs/org/apache/commons/configuration/AbstractConfiguration.html">
      AbstractConfiguration</a></code> can generate events of type
      <code><a href="../apidocs/org/apache/commons/configuration/event/ConfigurationEvent.html">
      ConfigurationEvent</a></code> when they are manipulated. In addition to
      the properties inherited from the <code>Event</code> base class, a
      configuration event contains all information available about the
      modification:
      <ul>
        <li>If available, the name of the property whose modification caused the
        event.</li>
        <li>If available, the value of the property that caused this event.</li>
        <li>A flag whether this event was generated before or after the update
        of the source configuration. A modification of a configuration typically
        causes two events: one event before and one event after the modification
        is performed. This allows event listeners to react at the correct point
        of time.</li>
      </ul>
      Depending on the concrete event type not all of this data may be available.
    </p>
    <p>
      <code>ConfigurationEvent</code> defines a number of <code>EventType</code>
      constants for the possible types of such an event. These constants
      correspond to the methods available for updating a configuration. The
      hierarchy of these event types is listed below, together with a
      description of the specific types and their available properties:
    </p>
    <p>
      <ul>
        <li><strong>Event.ANY</strong></li>
        <ul>
          <li><strong>ConfigurationEvent.ANY</strong> is a placeholder for all types
          of configuration update events. A listener registered for this
          event type is actually invoked for each manipulation of the source
          configuration.</li>
          <ul>
            <li><strong>ADD_PROPERTY</strong> A property was added to the
            configuration. The event object contains the name of the affected
            property and the value passed to the <code>addProperty()</code>
            method.</li>
            <li><strong>SET_PROPERTY</strong> The value of a property was
            changed. The event contains the name of the affected property and
            its new value.</li>
            <li><strong>CLEAR_PROPERTY</strong> A property was removed from the
            configuration. In the event the name of the removed property is
            stored.</li>
            <li><strong>CLEAR</strong> The whole configuration was cleared. The
            event object does not contain any additional information.</li>
            <li><strong>ANY_HIERARCHICAL</strong> This is a common super type
            for all events specific to hierarchical configurations. The event
            types derived from this type correspond to the special update
            methods supported by hierarchical configurations.</li>
            <ul>
              <li><strong>ADD_NODES</strong> A collection of nodes was added to
              a hierarchical configuration. The event contains the key passed
              to the <code>addNodes()</code> method and the collection of new
              nodes as value.</li>
              <li><strong>CLEAR_TREE</strong> This event is triggered by the
              <code>clearTree()</code> method. It contains the key of the
              sub tree which was removed; it has no value.</li>
              <li><strong>SUBNODE_CHANGED</strong> This event indicates that a
              <code>SubnodeConfiguration</code> created by this configuration
              was changed. The <em>value</em> property of the event object
              contains the original event object as it was sent by the subnode
              configuration.</li>
            </ul>
          </ul>
        </ul>
      </ul>
    </p>
    <p>
      After all the theory about the different event types, let's come to a
      concrete example. Implementing an event listener for configuration
      events is quite easy. To prove this and as a kind of "Hello world" use
      case, we are going to define an event listener which logs all received
      configuration events to the console. The class could look as follows:
    </p>
    <source><![CDATA[
import org.apache.commons.configuration.event.ConfigurationEvent;
import org.apache.commons.configuration.event.EventListener;

public class ConfigurationLogListener implements EventListener<ConfigurationEvent>
{
    public void onEvent(ConfigurationEvent event)
    {
        if (!event.isBeforeUpdate())
        {
            // only display events after the modification was done
            System.out.println("Received event!");
            System.out.println("Type = " + event.getEventType());
            if (event.getPropertyName() != null)
            {
                System.out.println("Property name = " + event.getPropertyName());
            }
            if (event.getPropertyValue() != null)
            {
                System.out.println("Property value = " + event.getPropertyValue());
            }
        }
    }
}
]]></source>
    <p>
      Now an instance of this event listener class has to be registered at a
      configuration object (Note: in a later section we will learn how event
      listeners can be added to configurations via their associated builders;
      this is the preferred way):
    </p>
    <source><![CDATA[
AbstractConfiguration config = ... // somehow create the configuration
EventListener<ConfigurationEvent> listener = new ConfigurationLogListener();
config.addEventListener(ConfigurationEvent.ANY, listener);
...
config.addProperty("newProperty", "newValue"); // will fire an event
]]></source>
    <p>
      Because our implementation is a very generic event listener it has been
      registered for all kinds of configuration update events - the event type
      <code>ConfigurationEvent.ANY</code> was used. Now consider the case that
      we only want to log events about cleared properties. This can be easily
      achieved - without having to modify the event listener implementation -
      by just changing the registration code in the following way:
    </p>
    <source><![CDATA[
config.addEventListener(ConfigurationEvent.CLEAR_PROPERTY, listener);
...
config.addProperty("newProperty", "newValue"); // will NOT fire an event
config.clearProperty("removedProperty"); // but this one will
]]></source>
    </subsection>

    <subsection name="Configuration Error Events">
    <p>
      Some implementations of the <code>Configuration</code> interface operate
      on underlying storages that can throw exceptions on each property access.
      As an example consider <code>
      <a href="../apidocs/org/apache/commons/configuration/DatabaseConfiguration.html">
      DatabaseConfiguration</a></code>: this configuration class issues an SQL
      statement for each accessed property, which can potentially cause a
      <code>SQLException</code>.
    </p>
    <p>
      Because the <code>Configuration</code> interface does not define checked
      exceptions for the methods which access properties such exceptions
      thrown from the underlying property store have to be handled somehow.
      One way would be to re-throw them as runtime exceptions. This is
      possible, a description how to enable this feature can be found in the
      <a href="howto_utilities.html#Handling_of_runtime_exceptions">Tips and
      Tricks</a> chapter. An alternative way of dealing with such exceptions is
      to register an event listener for error events.
    </p>
    <p>
      When a configuration implementation encounters an exception on accessing
      its data it generates an event of class
      <code><a href="../apidocs/org/apache/commons/configuration/event/ConfigurationErrorEvent.html">
      ConfigurationErrorEvent</a></code>. This event class has similar properties
      as <code><a href="../apidocs/org/apache/commons/configuration/event/ConfigurationEvent.html">
      ConfigurationEvent</a></code>. Especially the name and the value of the
      property which was accessed when the error occurred can be retrieved.
      In addition, there is the <code>getCause()</code> method which returns the
      exception causing this event.
    </p>
    <p>
      <code>ConfigurationErrorEvent</code> defines some new event type constants.
      They build up the following hierarchy:
      <ul>
        <li><strong>Event.ANY</strong></li>
        <ul>
          <li><strong>ConfigurationErrorEvent.ANY</strong> The common super type
          of all error events. An event listener registered for this type can
          be sure to be notified for all kind of error events.</li>
          <li><strong>ConfigurationErrorEvent.READ</strong> A sub type indicating
          that the error occurred while reading a property.</li>
          <li><strong>ConfigurationErrorEvent.WRITE</strong> A sub type
          indicating that the error occured on an update operation. In this
          case, an additional property of the event can be used to find out
          which operation was performed: <code>errorOperationType</code>
          returns an <code>EventType</code> object corresponding to the failed
          update method (e.g. <em>ConfigurationEvent.ADD_PROPERTY</em> if a
          property could not be added).</li>
        </ul>
      </ul>
    </p>
    <p>
      We could now continue the example from the previous section and make our
      sample logging event listener also capable of tracing error events. 
      However, this would not earn us that much. There is no principle difference
      in the handling of configuration update events and error events;
      therefore, there is nothing new to learn. If the logging functionality
      should be implemented in a single listener class, the only tricky part is
      that <code>ConfigurationEvent</code> and <code>ConfigurationErrorEvent</code>
      do not stand in a super/extends relation with each other; they are both
      derived from the type <em>Event.ANY</em>. So a generic logging listener
      would have to be of type <code>EventListener&lt;Event&gt;</code>, and it
      would have to use the event's type to determine how to handle this
      concrete event. Creating a separate event listener class for logging error
      events is certainly easier.
    </p>
    <p>
      Note: <code>AbstractConfiguration</code> already implements a mechanism
      for writing internal errors to a logger object: It has the
      <code>addErrorLogListener()</code> method that can be called from derived
      classes to register a listener that will output all occurring internal
      errors using the default logger. Configuration implementations like
      <code>DatabaseConfiguration</code> that are affected by potential internal
      errors call this method during their initialization. So the default
      behavior of <em>Commons Configuration</em> for these classes is to
      catch occurring exceptions and log them. However, by
      registering specific error listeners it is possible for clients to
      implement their own handling of such errors.
    </p>
    </subsection>
    </section>
</body>

</document>