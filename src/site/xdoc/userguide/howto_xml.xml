<?xml version="1.0"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<document>

 <properties>
  <title>XML Configurations</title>
 </properties>

<body>
    <section name="XML Configurations">
    <p>
      An important sub category of hierarchical configurations files are XML
      documents. <em>Commons Configuration</em> ships with the
      <code><a href="../apidocs/org/apache/commons/configuration/XMLConfiguration.html">
      XMLConfiguration</a></code> class that can read and write files of this
      type. All features described in the chapter about
      <a href="howto_hierarchical.html">Hierarchical Configurations</a> are
      supported by XML configurations as well. In this chapter the additional
      functionality offered by the <code>XMLConfiguration</code> class is
      discussed.
    </p>
    </section>

    <section name="Validation of XML configuration files">
        <p>
            XML parsers provide support for validation of XML documents to ensure that they
            conform to a certain DTD or XML Schema. This feature can be useful for
            configuration files, too. <code>XMLConfiguration</code> allows this feature
            to be enabled when files are loaded.
        </p>
        <subsection name="Validation using a DTD">
        <p>
            The easiest way to turn on validation is to simply set the
            <code>validating</code> property to <strong>true</strong> in the
            initialization parameters of the configuration builder as shown in
            the following example:
        </p>
        <source><![CDATA[
Parameters params = new Parameters();
FileBasedConfigurationBuilder<XMLConfiguration> builder =
    new FileBasedConfigurationBuilder<XMLConfiguration>(XMLConfiguration.class)
    .configure(params.xml()
        .setFileName("myconfig.xml")
        .setValidating(true));

// This will throw a ConfigurationException if the XML document does not
// conform to its DTD.
XMLConfiguration config = builder.getConfiguration();
]]></source>
        <p>
            Setting the <code>validating</code> flag to <strong>true</strong> will cause
            <code>XMLConfiguration</code> to use a validating XML parser. At this parser
            a custom <code>ErrorHandler</code> will be registered, which throws
            exceptions on simple and fatal parsing errors.
        </p>
        </subsection>
        <subsection name="Validation using a Schema">
        <p>
            XML Parsers also provide support for validating XML documents using an
            XML Schema. XMLConfiguration provides a simple mechanism for enabling
            this by setting the <code>schemaValidation</code> flag to true. This
            will also set the <code>validating</code> flag to true so both do not
            need to be set. The XML Parser will then use the schema defined in the
            XML document to validate it. Enabling schema validation will also
            enable the parser's namespace support.
        </p>
        <p>
        <source><![CDATA[
XMLConfiguration config = new XMLConfiguration();
config.setFileName("myconfig.xml");
config.setSchemaValidation(true);

// This will throw a ConfigurationException if the XML document does not
// conform to its Schema.
config.load();
]]></source>
        </p>
        </subsection>
        <subsection name="Default Entity Resolution">
        <p>
            There is also some support for dealing with DTD files. Often the
            DTD of an XML document is stored locally so that it can be quickly
            accessed. However the <code>DOCTYPE</code> declaration of the document
            points to a location on the web as in the following example:
        </p>
        <source><![CDATA[
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE web-app
  PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN"
  "http://java.sun.com/j2ee/dtds/web-app_2.2.dtd">
]]></source>
        <p>
            When working with XML documents directly you would use an
            <code>EntityResolver</code> in such a case. The task of such an
            entity resolver is to point the XML parser to the location of the
            file referred to by the declaration. So in our example the entity
            resolver would load the DTD file from a local cache instead of
            retrieving it from the internet.
        </p>
        <p>
            <code>XMLConfiguration</code> provides a simple default implementation of
            an <code>EntityResolver</code>. This implementation is initialized
            by calling the <code>registerEntityId()</code> method with the
            public IDs of the entities to be retrieved and their corresponding
            local URLs. This method has to be called before the configuration
            is loaded. To continue our example, consider that the DTD file for
            our example document is stored on the class path. We can register it
            at <code>XMLConfiguration</code> using the following code:
        </p>
        <source><![CDATA[
XMLConfiguration config = new XMLConfiguration();
// load the URL to the DTD file from class path
URL dtdURL = getClass().getResource("web-app_2.2.dtd");
// register it at the configuration
config.registerEntityId("-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN",
    dtdURL);
config.setValidating(true);  // enable validation
config.setFileName("web.xml");
config.load();
]]></source>
        <p>
            This basically tells the XML configuration to use the specified
            URL when it encounters the given public ID. Note that the call to
            <code>registerEntityId()</code> has to be performed before the
            configuration is loaded. So you cannot use one of the constructors
            that directly load the configuration.
        </p>
        </subsection>
        <subsection name="Enhanced Entity Resolution">
        <p>
            While the default entity resolver can be used under certain circumstances,
            it does not work well when using the DefaultConfigurationBuilder.
            Furthermore, in many circumstances the programmatic nature of
            registering entities will tie the application tightly to the
            XML content. In addition, because it only works with the public id it
            cannot support XML documents using an XML Schema.
        </p>
        <p>
            <a href="http://xml.apache.org/commons/components/resolver/resolver-article.html#s.whats.wrong">XML
            Entity and URI Resolvers</a> describes using a set of catalog files to
            resolve enitities. Commons Configuration provides support for
            this Catalog Resolver through its own CatalogResolver class.
        </p>
         <source><![CDATA[
<?xml version="1.0" encoding="ISO-8859-1"?>
<Employees xmlns="http://commons.apache.org/employee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://commons.apache.org/employee http://commons.apache.org/sample.xsd">
  <Employee>
    <SSN>555121211</SSN>
    <Name>John Doe</Name>
    <DateOfBirth>1975-05-15</DateOfBirth>
    <EmployeeType>Exempt</EmployeeType>
    <Salary>100000</Salary>
  </Employee>
</Employees>]]></source>
        <p>
            The XML sample above is an XML document using a default namespace of
            http://commons.apache.org/employee. The schemaLocation allows a set
            of namespaces and hints to the location of their corresponding
            schemas. When processing the document the parser will pass the hint,
            in this case http://commons.apache.org/sample.xsd, to the entity resolver
            as the system id. More information on using schema locations can be found
            at <a href="http://www.w3.org/TR/xmlschema-0/#schemaLocation">schemaLocation</a>.
        </p>
        <p>
            The example that follows shows how to use the CatalogResolver when
            processing an XMLConfiguration. It should be noted that by using the
            setEntityResolver method any EntityResolver may be used, not just those
            provided by Commons Configuration.
        </p>
        <source><![CDATA[
CatalogResolver resolver = new CatalogResolver();
resolver.setCatalogFiles("local/catalog.xml","http://test.org/catalogs/catalog1.xml");
XMLConfiguration config = new XMLConfiguration();
config.setEntityResolver(resolver);
config.setSchemaValidation(true);  // enable schema validation
config.setFileName("config.xml");
config.load();
]]></source>
        </subsection>
        <subsection name="Extending Validation and Entity Resolution">
        <p>
            The mechanisms provided with Commons Configuration will hopefully be
            sufficient in most cases, however there will certainly be circumstances
            where they are not. XMLConfiguration provides two extension mechanisms
            that should provide applications with all the flexibility they may
            need. The first, registering a custom Entity Resolver has already been
            discussed in the preceeding section. The second is that XMLConfiguration
            provides a generic way of setting up the XML parser to use: A preconfigured
            <code>DocumentBuilder</code> object can be passed to the
            <code>setDocumentBuilder()</code> method.
        </p>
        <p>
            So an application can create a <code>DocumentBuilder</code> object
            and initialize it according to its special needs. Then this
            object must be passed to the <code>XMLConfiguration</code> instance
            before invocation of the <code>load()</code> method. When loading
            a configuration file, the passed in <code>DocumentBuilder</code> will
            be used instead of the default one. <em>Note:</em> If a custom
            <code>DocumentBuilder</code> is used, the default implementation of
            the <code>EntityResolver</code> interface is disabled. This means
            that the <code>registerEntityId()</code> method has no effect in
            this mode.
        </p>
        </subsection>
    </section>
</body>

</document>