<?xml version="1.0"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<document>

 <properties>
  <title>Migration Guide for 2.0</title>
 </properties>

<body>
    <section name="Migration Guide to Version 2.0">
    <p>
      Version 2.0 of <em>Commons Configuration</em> is the result of a major
      redesign of this library. Some concepts used within the 1.x version
      series have changed significantly or have even been replaced by alternative
      approaches. Therefore, you cannot simply drop the new jar in your classpath
      and expect that everything continues to work.
    </p>
    <p>
      This document aims at supporting with the migration from version 1.x of
      <em>Commons Configuration</em> to version 2.0. Target audience are
      users of an older version who want to upgrade. The document describes the
      problems which are likely to be encountered during this migration and
      discusses possible strategies or solutions.
    </p>
    <p>
      Also note that the <a href="user_guide.html">user's guide</a> has been
      fully reworked to cover all the new features and concepts offered by
      <em>Commons Configuration</em> 2.0. Because of that, this document will not
      describe interfaces or classes in detail, but simply refer to the
      corresponding sections of the user guide.
    </p>
    <p>
      This document has the following content:
      <ul>
        <li><a href="#Structural_Changes">Structural Changes</a></li>
        <li><a href="#Accessing_Configuration_Properties">Accessing Configuration Properties</a></li>
        <li><a href="#Creating_Configurations">Creating Configurations</a></li>
        <li><a href="#Reloading">Reloading</a></li>
      </ul>
    </p>

    <subsection name="Structural Changes">
    <p>
      The most obvious change you will notice at the very beginning is that
      the root package was renamed to <code>org.apache.commons.configuration2</code>
      - the major version is now part of the package name. This certainly makes
      migration harder, but it is the only possibility to avoid jar hell.
      Imagine for a moment that we had kept the old package name. This
      would work well for applications that are the only user of the
      <em>Commons Configuration</em> library. But as soon as there are 3rd
      party libraries also using this component, but in version 1.x, then there
      is real trouble: The class path then contains classes with identical
      names in different versions - results will be unpredictable! The change
      of the package name solves this problem because the new version can now
      co-exist with an old version without interfering.
    </p>
    <p>
      For the same reason the <a href="http://maven.apache.org">Maven</a>
      coordinates have been changed. Use the following dependency declaration
      in your pom:
    </p>
    <source><![CDATA[
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-configuration2</artifactId>
  <version>2.0</version>
</dependency>
]]></source>
    <p>
      So for Maven version 2.0 is a completely different artifact. This
      allows a peaceful co-existence of <em>Commons Configuration</em> 1.x and
      2.0 in the dependency set of a project.
    </p>
    </subsection>

    <subsection name="Accessing Configuration Properties">
    <p>
      The good news is that there are only minor changes in the central
      <code><a href="../apidocs/org/apache/commons/configuration/Configuration.html">
      Configuration</a></code> interface used for reading and writing configuration
      data. A few methods have been added supporting new features, but the
      principle patterns for dealing with <code>Configuration</code> objects
      remain valid. These concepts are described in the user's guide in the
      sections <a href="overview.html#Using_Configuration">Using Configuration</a>
      and <a href="howto_basicfeatures.html#Basic_features_and_AbstractConfiguration">Basic
      features and AbstractConfiguration</a>.
    </p>
    <p>
      What has changed is the default implementation of
      <a href="howto_basicfeatures.html#List_handling">List handling</a> in
      <code><a href="../apidocs/org/apache/commons/configuration/AbstractConfiguration.html">
      AbstractConfiguration</a></code>. In version 1.x list splitting was
      enabled per default; string properties containing a &quot;,&quot; character
      were interpreted as lists with multiple elements. This was a frequent
      source for confusion and bug reports. In version 2.0 list splitting is now
      disabled initially. The implementation also has been extended: it is no
      longer limited to providing a delimiter character, but an implementation
      of the <code><a href="../apidocs/org/apache/commons/configuration/convert/ListDelimiterHandler.html">
      ListDelimiterHandler</a></code> interface can be set which controls all
      aspects of list handling. In order to enable list handling again, pass a
      <code><a href="../apidocs/org/apache/commons/configuration/convert/DefaultListDelimiterHandler.html">
      DefaultListDelimiterHandler</a></code> object to your
      <code>AbstractConfiguration</code> instance. This class supports splitting
      string properties at specific delimiter characters. However, its results
      are not 100% identical to the ones produced by <em>Commons Configuration</em>
      1.0: this version contained some inconsistencies regarding the escaping of
      list delimiter characters. If you really need the same behavior in this
      area, then use the
      <code><a href="../apidocs/org/apache/commons/configuration/convert/LegacyListDelimiterHandler.html">
      LegacyListDelimiterHandler</a></code> class.
    </p>
    <p>
      Version 2.0 also has changes related to
      <a href="howto_hierarchical.html#Hierarchical_Configurations">Hierarchical
      Configurations</a>.
      <code><a href="../apidocs/org/apache/commons/configuration/HierarchicalConfiguration.html">
      HierarchicalConfiguration</a></code>, formally the base class for all
      hierarchical configurations, is now an interface. The equivalent to the
      old base class is now named
      <code><a href="../apidocs/org/apache/commons/configuration/BaseHierarchicalConfiguration.html">
      BaseHierarchicalConfiguration</a></code>. It extends the abstract base class
      <code><a href="../apidocs/org/apache/commons/configuration/AbstractHierarchicalConfiguration.html">
      AbstractHierarchicalConfiguration</a></code>. The difference between these
      classes is that <code>AbstractHierarchicalConfiguration</code> provides
      generic algorithms for dealing with an arbitrary hierarchical node
      structure. <code>BaseHierarchicalConfiguration</code> in contrast defines
      its own node structure based on objects kept in memory. In future, it
      should be possible to support other kinds of hierarchical structures
      directly by creating specialized sub classes from
      <code>AbstractHierarchicalConfiguration</code>. Refer to section
      <a href="howto_hierarchical.html#Internal_Representation">Internal Representation</a>
      for further information. The node objects a hierarchical configuration
      deals with are now exposed as a generic type parameter; for instance,
      <code>BasieHierarchicalConfiguration</code> is actually an
      <code>AbstractHierarchicalConfiguration&lt;ImmutableNode&gt;</code>.
      For most applications only interested in accessing configuration data via
      the typical access methods, this parameter is not relevant and can be
      replaced by a wildcard (&quot;?&quot;) in variable declarations. Extended
      query facilities on hierarchical configurations work in the same way as
      in version 1.x; so applications need not be updated in this area.
    </p>
    </subsection>

    <subsection name="Creating Configurations">
    <p>
      A major difference between <em>Commons Configuration</em> 1.x and 2.0 is
      the way configuration objects are created, initialized, and managed. In
      version 1.x configurations are created directly using their constructor.
      Especially for file-based configuration implementations - like
      <code><a href="../apidocs/org/apache/commons/configuration/PropertiesConfiguration.html">
      PropertiesConfiguration</a></code> or
      <code><a href="../apidocs/org/apache/commons/configuration/XMLConfiguration.html">
      XMLConfiguration</a></code> - there were constructors which immediately
      populate the newly created instances from a data source. If additional
      settings were to be applied, this was done after the creation using
      bean-like set methods. For instance, in order to create an initialized
      <code>PropertiesConfiguration</code> object, the following code could be
      used:
    </p>
    <source><![CDATA[
// Version 1.x: Initializing a properties configuration
PropertiesConfiguration config = new PropertiesConfiguration("myconfig.properties");
config.setThrowExceptionOnMissing(true);
config.setIncludesAllowed(false);
config.setListDelimiter(';');
]]></source>
    <p>
      While this code is easy to write, there are some non-obvious problems:
      <ul>
        <li>Some settings influence the loading of the configuration data. In
        this example, the definition of the list delimiter and the
        <em>includesAllowed</em> flag fall into this category. However, because
        the data is directly loaded by the constructor these settings are
        applied too late and thus ignored by the load operation.</li>
        <li>The constructor calls a protected method for loading the data. This
        can lead to subtil bugs because at this time the instance is not yet
        fully initialized.</li>
        <li>The various set methods are not thread-safe; if this configuration
        instance is to be accessed from another thread, there may be problems.</li>
      </ul>
    </p>
    <p>
      To overcome these problems, <em>Commons Configuration</em> uses a
      different approach for the creation of configuration objects based on
      <a href="howto_builders.html">configuration builders</a>. The basic idea
      is that a configuration builder is created and initialized with all
      parameters to be applied to the new configuration object. When the
      configuration instance is queried from its builder it is guaranteed that
      it has been fully initialized in the correct order. In addition, access
      to configuration builders is thread-safe. Configuration builders offer a
      fluent API for setting the initialization parameters for the configuration
      to be created. The example above would become something like the
      following in version 2.0:
    </p>
        <source><![CDATA[
FileBasedConfigurationBuilder<PropertiesConfiguration> builder =
    new FileBasedConfigurationBuilder<PropertiesConfiguration>(PropertiesConfiguration.class)
    .configure(new Parameters().properties()
        .setFileName("myconfig.properties")
        .setThrowExceptionOnMissing(true)
        .setListDelimiterHandler(new DefaultListDelimiterHandler(';))
        .setIncludesAllowed(false));
PropertiesConfiguration config = builder.getConfiguration();
]]></source>
    <p>
      Builders also offer an increased flexibility regarding the management of
      configuration objects. While in version 1.x of <em>Commons Configuration</em>
      typically <code>Configuration</code> objects were kept centrally and
      accessed throughout an application, the recommended way in version 2.0 is
      to work with configuration builders. A builder not only creates a new
      configuration object but also caches a reference to it so that it can be
      accessed again and again. This makes it possible to add special
      functionality to the builder. For instance, it may decide to return a
      different configuration object under certain circumstances - e.g. when a
      change on an external configuration source is detected and a reload
      operation is performed. For the application this is fully transparent.
    </p>
    <p>
      Working with builders may seem a bit verbose first. There are some ways
      to simplify their usage. Be sure to read the section
      <a href="howto_filebased.html#Making_it_easier">Making it easier</a>
      which describes some useful short cuts. It is also possible to define
      default values for initialization parameters. This allows simplifying of
      builder configurations and can establish application-global standard
      settings for configuration objects. This mechanism is described in
      <a href="howto_builders.html#Default_Initialization_Parameters">Default
      Initialization Parameters</a>.
    </p>
    </subsection>

    <subsection name="Reloading">
    <p>
      Support for reloading of externally changed configuration sources was
      limited in <em>Commons Configuration</em> 1.x. There was a reloading
      strategy implementation that was triggered on each access to a
      configuration property and checked whether an underlying file was changed
      in the meantime. If this was the case, the configuration was automatically
      reloaded. <a href="https://issues.apache.org/jira/browse/CONFIGURATION-520">
      CONFIGURATION-520</a> contains a discussion about the problems and
      limitations of this approach.
    </p>
    <p>
      In version 2.0 reloading functionality has been completely redesigned.
      The new approaches are described in the chapter
      <a href="howto_reloading.html">Automatic Reloading of Configuration
      Sources</a> of the user's guide. In a nutshell,
      <a href="howto_builders.html">configuration builders</a> play an important
      role here. There are builder implementations available which can be
      configured to monitor external configuration sources in a pretty generic
      way. When a change is detected, the builder resets its managed configuration
      so that the next time it is accessed a new instance is created. In addition,
      an event can be generated notifying the application that new configuration
      information might be available. The whole mechanism can be setup to
      perform reloading checks periodically and automatically in a background
      thread.
    </p>
    <p>
      The <code>FileChangedReloadingStrategy</code> class from version 1.0
      does no longer exist. It is replaced by the new, more powerful reloading
      mechanisms. The mentioned chapter about <a href="howto_reloading.html">reloading</a>
      describes in detail how a reloading-aware configuration builder can be
      setup and fine-tuned to an application's needs.
    </p>
    </subsection>
  </section>
</body>

</document>